---
title: "DSC 465 - Group Project"
author: "GraphGurus - Ken Vellian, Francisco Lozano"
date: "2024-03-19"
output:
  html_document: default
  pdf_document: default
---

Color resources: <https://sape.inf.usi.ch/quick-reference/ggplot2/colour> <https://r-graph-gallery.com/38-rcolorbrewers-palettes.html> <https://ggplot2.tidyverse.org/reference/ggtheme.html> <https://r-graph-gallery.com/79-levelplot-with-ggplot2.html>

## Constants

```{r}
dataset_file <- "real_estate_texas_500_2024.csv"
#create_file <- "real_estate_texas_500_2024_ADDRESS.csv"
```

## Libraries

```{r, message=FALSE, results='hide'}
library(tidyverse)
library(mosaic)
library(lubridate)
library(reshape)
library(reshape2)
library(gcookbook)
library(scales)
library(mapproj)
library(zoo)
library(gridExtra)
library(RColorBrewer)


library(datasets)
library(ggforce)
library(ggbeeswarm)
library(ggmosaic)

library(magrittr)
library(scales)
library(tidyquant)
library(readr)
library(ggpubr)
library(stringr)

library(tinytex)
library(rmarkdown)

library(fastDummies)
library(caret)
library(dplyr)
library(RANN)
```

## Discovery

```{r}
tx_data <- read.csv(dataset_file)
```

```{r}
glimpse(tx_data)
```

```{r}
# Checking count of all NAs in the tx_data

sum(is.na(tx_data))
```

```{r}
summary(tx_data)
```

## Ken Vellian: Retrieving Address

```{r}
# Extracting the street_address, city, state, and zip

# Defining the regex pattern with capture groups for each value of the columns
url_groups <- "realestateandhomes-detail\\/([^_]+)_([^_]+)_([^_]+)_([0-9]{5})"

# str_match returns matches for each capture group in the url column
str_matches <- str_match(tx_data$url, url_groups)

# Assigning the matched capture groups to new columns in the tx_data
tx_data$street_address <- str_matches[, 2]
tx_data$city <- str_matches[, 3]
tx_data$state <- str_matches[, 4]
tx_data$zip <- str_matches[, 5]

# Replacing the dash delimiter in the street address and city with a single space
tx_data$street_address <- gsub("-", " ", tx_data$street_address)
tx_data$city <- gsub("-", " ", tx_data$city)

# Converting ZIP from chr to int
tx_data$zip <- as.integer(tx_data$zip)

# Removing the url column (not needed anymore) and status column (all statuses are for_sale, redundant)
# tx_data <- select(tx_data, -url, -status)

# Checking results
head(tx_data)

```

```{r}
# numeric vector that calculates the sum of NAs per column in the tx_data data.
nas_per_column<- colSums(is.na(tx_data))

print(nas_per_column)
```

> > Findings: id: 9318998668 does not have a street address. Therefore, its entries are NA. We'll discuss dropping this row.

```{r}
# View(tx_data)
```

```{r}
glimpse(tx_data)
```

## Francisco Lozano: Filling NAs

### Discovery

```{r}
tx_data_no_land_farm <- filter(tx_data, type != "land" & type != "farm")

#print rows with na
rows_with_na <- subset(tx_data_no_land_farm, apply(is.na(tx_data_no_land_farm), 1, any))
# view(rows_with_na)
```

> Rows that are type "land" and "farm" have NAs since no house is built

### Francisco Lozano: Filling NA for Rows with type land or farm

> These values are suppose to be zero no house in the property

```{r}
#baths
tx_data$baths[tx_data$type %in% c("land", "farm") & is.na(tx_data$baths)] <- 0
#baths_full
tx_data$baths_full[tx_data$type %in% c("land", "farm") & is.na(tx_data$baths_full)] <- 0
#baths_full_calc
tx_data$baths_full_calc[tx_data$type %in% c("land", "farm") & is.na(tx_data$baths_full_calc)] <- 0
#beds
tx_data$beds[tx_data$type %in% c("land", "farm") & is.na(tx_data$beds)] <- 0
#stories
tx_data$stories[tx_data$type %in% c("land", "farm") & is.na(tx_data$stories)] <- 0
#sqft
tx_data$sqft[tx_data$type %in% c("land", "farm") & is.na(tx_data$sqft)] <- 0
#year_built
tx_data$year_built[tx_data$type %in% c("land", "farm") & is.na(tx_data$year_built)] <- 0
```

### Francisco Lozano: Dropping Records

> Since these records have too many NAs it will be hard to predict what was the missing value, so they will dropped. I also dropped a record with no location data

```{r}
tx_data <- filter(tx_data, id != 9031060769) 
tx_data <- filter(tx_data, id != 9530697722) 
tx_data <- filter(tx_data, id != 9634827807) 
tx_data <- filter(tx_data, id != 9318998668) 
```

### Francisco Lozano: Filling "stories" & "sqft" with KNN Imputation

#### Francisco Lozano: Finding Clusters

> Trying to find clusters to see if KNN imputation will work. Based on the graph, you can see, houses with the same stories are clustering based on bath and sqft.

```{r, message=FALSE, results='hide'}
#create temp df
temp <- tx_data

#removing outliers
temp <- filter(temp, id != 9887837817) #remove listPrice outlier
temp <- filter(temp, id != 9697989595) #remove sqft outlier

#filter land and farms, since we know these always have 0 in sqft, bath, & stories
temp <- filter(temp, !(type %in% c("land", "farm") ))

# Get unique values of 'stories' excluding NA
story_values <- na.omit(unique(temp$stories))

# Define a color palette with enough colors for each unique 'stories' value
color_palette <- colorRampPalette(brewer.pal(5, "Set2"))(length(story_values))

# Create the beeswarm plot
ggplot(temp, aes(x = baths, y = sqft, color = factor(stories))) + 
  geom_beeswarm(cex = 1.2, show.legend = TRUE) + 
  scale_color_manual(values = c(color_palette),
                     na.value = "blue",
                     guide = guide_legend(title = "stories")) +
  theme_minimal() +
  scale_x_continuous(breaks = unique(temp$baths), labels = unique(temp$baths)) +
  labs(title = "Sqft vs Baths",
       x = "# of Baths",
       y = "Sqft",
       color = '# of Floors') +
  theme(legend.position = "bottom") +
  theme(axis.text.x = element_text(hjust = 1, size = 10),
        axis.text.y = element_text(size = 10),
        plot.title = element_text(size = 16, hjust = 0.5), 
        axis.title = element_text(size = 12)) 
```

#### Francisco Lozano: Performing KNN imputation

```{r}
temp <- tx_data
temp <- subset(temp, select = c(baths, baths_full, baths_full_calc, beds, sqft, stories))
stories <- subset(temp, select = stories)

preProcValues <- preProcess(temp,
                            method = c("knnImpute"),
                            k = 5,
                            knnSummary = median)
impute_temp <- predict(preProcValues, temp,na.action = na.pass)

#denormalize the returned vals
procNames <- data.frame(col = names(preProcValues$mean), mean = preProcValues$mean, sd = preProcValues$std)
for(i in procNames$col){
 impute_temp[i] <- impute_temp[i]*preProcValues$std[i]+preProcValues$mean[i] 
}

# view(impute_temp)
```

#### Francisco Lozano: Looking at the Clusters again

> Comparing both before and after KNN imputation, seems like the KNN imputation did not output any extraordinary values. Most NAs in "stories" got replaced by most frequent "stories" value in clusters seen in the graph.

```{r}
impute_temp$type <- tx_data$type
temp <- impute_temp %>%
  filter(sqft != 67139) %>%  # Remove sqft outlier
  filter(!(type %in% c("land", "farm") )) #filter for same reason as before

# Create the beeswarm plot
ggplot(temp, aes(x = baths, y = sqft, color = factor(stories))) + 
  geom_beeswarm(cex = 1.2, show.legend = TRUE) + 
  scale_color_manual(values = c(color_palette),
                     na.value = "blue",
                     guide = guide_legend(title = "stories")) +
  theme_minimal() +
  scale_x_continuous(breaks = unique(temp$baths), labels = unique(temp$baths)) +
  labs(title = "Sqft vs Baths",
       x = "# of Baths",
       y = "Sqft",
       color = '# of Floors') +
  theme(legend.position = "bottom") +
  theme(axis.text.x = element_text(hjust = 1, size = 10),
        axis.text.y = element_text(size = 10),
        plot.title = element_text(size = 16, hjust = 0.5), 
        axis.title = element_text(size = 12)) 
```

#### Francisco Lozano: Transfer the values

```{r}
#transfer imputed values to original df
tx_data$stories <- impute_temp$stories
tx_data$sqft <- impute_temp$sqft #there is only one NA for sqft
```

### Francisco Lozano: Filling "year_built"

```{r}
#year_built
tx_data$year_built[is.na(tx_data$year_built)] <- 1
```

Fill NA with 1, to signify unknown

### Francisco Lozano: Checking for NA again

```{r}
#print rows with na
rows_with_na <- subset(tx_data, apply(is.na(tx_data), 1, any))
# View(rows_with_na)
```

### Ken Vellian: Creating regex pattern to fill in missing sqft values

```{r}

# Regex to find acre values in the text column 
regex_acres <- "\\d+\\.?\\d*\\s*[-+]?/?\\s*(acre|acres|AC|Acre|acre)"

tx_data <- tx_data %>%
  mutate(
    # Extracting the acres from the text column
    extract_acres = str_extract(text, regex_acres),
    # Formatting string to be used for calculation
    clean_acres = gsub("[^0-9.]", "", extract_acres), # Removing the non-numeric characters
    value_acres = as.numeric(clean_acres),
    # Converting acres to sqft if it is 0 and value_acres is not NA
    sqft = ifelse(sqft == 0 & !is.na(value_acres), value_acres * 43560, sqft)) %>%
  select(-extract_acres, -clean_acres, -value_acres) # Removing temporary columns

```

## Output File

```{r}
# Writing updated tx_data to csv to share with team
# write.csv(tx_data, file = create_file, row.names = FALSE)
```

## Francisco Lozano's graphs

### Top 10 Most Expensive Cities for SFH

```{r, message=FALSE, results='hide'}
temp <- tx_data %>%
  filter(type == "single_family") %>%
  group_by(city) %>%
  summarise(pricebysqft = mean(listPrice/(sqft+1))) #shift data by one for zero vals in sqft


temp %>%
top_n(10, pricebysqft) %>%
  mutate(city_color = ifelse(city == "Austin", "Austin", "Other")) %>%
  ggplot() +
  geom_bar(aes(x = pricebysqft,
               y = reorder(city,+pricebysqft),
               fill = city_color),
           stat = "identity") +
  scale_fill_manual(values = c("Other" = "darkgrey", "Austin" = "red")) +
  labs(title = "Top 10 Most Expensive Cities For Single Family Homes by Sqft",
       x = "Average Price Per Sqft ($)",
       y = "City") +
  theme_minimal() +
  theme(axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        plot.title = element_text(size = 16, hjust = 0.5),
        axis.title = element_text(size = 16)) +
  guides(fill = "none")

#ggsave("Top10_Expensive_SFH.png", width = 10, height = 6, dpi = 300)
```


## Ken Vellian's graphs

### 1. Milestone 2: Panel Scatterplot for initial exploratory visualization

```{r, warning= FALSE}
# Creating scatterplots of Square Footage vs. List Price by Property Type

# Filtering out data where sqft != 0
filtered_sqft <- tx_data %>%
  filter(sqft != 0)

ggplot(filtered_sqft, aes(x = listPrice, y = sqft)) + 
  geom_point(aes(color = type), alpha = 0.7) + 
  facet_wrap(~ type, scales = "free") + # Creating a separate plot for each property type
  scale_y_log10() + # Applying log 10
  labs(title = "Square Footage vs. List Price by Property Type",
       x = "List Price",
       y = "Square Footage (Log Scale 10)") +
  theme_bw() + # Using bw theme
  theme(plot.title = element_text(hjust = 0.5), # Centering the plot titles
        axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "right",
        legend.background = element_rect(fill = "white", 
                                                 color = "black", size = 1, linetype = "solid"))

ggsave("sqft_vs_price.png", width = 10, height = 6, dpi = 300)

```

### 2. Milestone 3,4: Revised Bar plot

```{r, warning = FALSE}
#Potentially use for Milestone 3/4

# Ordering data by count descending
tx_data$type <- factor(tx_data$type, levels = names(sort(table(tx_data$type), decreasing = TRUE)))

# Define appropriate labels for the x-axis
x_labels <- c("single_family" = "Single Family Homes", "land" = "Land", "farm" = "Farm", "mobile" = "Mobile Homes", "townhomes" = "Town Homes", "condos" = "Condos")

# Define colors for each property type
type_colors <- c("single_family" = "lightpink1", "land" = "tan4", "farm" = "olivedrab3", "mobile" = "cadetblue2", "townhomes" = "cornflowerblue", "condos" = "plum3")

# Bar chart with count by property type
ggplot(data = tx_data, aes(x = type, fill = type)) +
  geom_bar(stat = "count", color = "black") +
  geom_text(stat = 'count', aes(label = ..count..), vjust = -1) +
  labs(title = "Count of Properties by Type in Texas Real Estate Listings",
       x = "Property Type",
       y = "Count") +
  scale_fill_manual(values = type_colors) + # Setting custom colors
  scale_y_continuous(limits = c(0, max(table(tx_data$type)) * 1.1)) + # Extending y limit to prevent geom_text cutoff
  scale_x_discrete(labels = x_labels) + # Rename x labels
  theme_linedraw() +
  theme(legend.position = "none",
        axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
        axis.text.y = element_text(size = 10),
        plot.title = element_text(size = 20, hjust = 0.5), 
        axis.title = element_text(size = 16),
        panel.grid.major = element_blank(), # Removing gridlines
        panel.grid.minor = element_blank())

ggsave("count_bar_plot.png", width = 10, height = 6, dpi = 300)

```

### 3. Milestone 3,4: Revised histogram/KDE curve used


```{r}
# Filtering for single_family type, this will be for multiple visualizations
single_family_homes <- tx_data[tx_data$type == "single_family",]
```


```{r}
# Defining bin width at 200
binwidth <- 200

# Calculating the scaling factor for the KDE curve
scaling_factor <- binwidth * nrow(single_family_homes)

# Plotting the histogram with density line
ggplot(single_family_homes, aes(x = sqft)) +
  geom_histogram(binwidth = binwidth, color = "black", fill = "skyblue") +
  # Smoothing the density line using adjust = 2.0
  geom_density(aes(y = ..density.. * scaling_factor), color = "red2", fill = "red2", alpha = 0.5, adjust = 2.0) +
  labs(title = "Distribution of Square Footage for Single Family Homes",
       x = "Square Footage",
       y = "Number of Listings") +
  scale_x_continuous(breaks = seq(0, 7000, by = 1000)) +
  scale_y_continuous(breaks = seq(0, 55, by = 5)) + 
  theme_linedraw() +
  theme(axis.text.x = element_text(size = 13),
        axis.text.y = element_text(size = 13),
        plot.title = element_text(size = 20, hjust = 0.5), 
        axis.title = element_text(size = 16),
        panel.grid.major = element_blank(), # Removing gridlines
        panel.grid.minor = element_blank())

ggsave("sqft_dist.png", width = 10, height = 6, dpi = 300)

```

```{r}
mean(single_family_homes$sqft)
```

### 4. Milestone 3,4: Revised histogram/KDE curve

```{r}
# Defining bin width for the histogram
binwidth <- 50000

# Calculating the scaling factor for the KDE curve
scaling_factor <- binwidth * nrow(single_family_homes)

# Plotting the histogram with density line for the listing prices of single-family homes
ggplot(single_family_homes, aes(x = listPrice)) +
  geom_histogram(binwidth = binwidth, color = "black", fill = "darkolivegreen3") +
  geom_density(aes(y = ..density.. * scaling_factor), color = "red2", fill = "red2", alpha = 0.5, adjust = 2.0) +
  labs(title = "Distribution of Listing Price for Single Family Homes",
       x = "Listing Price ($)",
       y = "Number of Listings") +
  scale_x_continuous(labels = scales::comma, 
                     breaks = seq(0, max(single_family_homes$listPrice), by = 250000)) + # More x-axis breaks
  theme_linedraw() +
  theme(axis.text.x = element_text(size = 13, angle = 45, hjust = 1),
        axis.text.y = element_text(size = 13),
        plot.title = element_text(size = 20, hjust = 0.5), 
        axis.title = element_text(size = 16),
        panel.grid.major = element_blank(), # Removing gridlines
        panel.grid.minor = element_blank())

ggsave("price_dist.png", width = 10, height = 6, dpi = 300)

```

```{r}
mean(single_family_homes$listPrice)
```

### 5. Milestone 3,4: Scatterplot of Baths vs Beds with jitter. Revised into heatmap for final report.

```{r}
# Scatter plot for Bathrooms vs. Bedrooms with jitter
ggplot(single_family_homes, aes(x = beds, y = baths)) +
  geom_jitter(aes(color = factor(beds)), width = 0.3, height = 0.3, alpha = 0.7) +
  labs(title = "Bathrooms vs. Bedrooms for Single Family Homes in Texas",
       x = "Count of Bedrooms",
       y = "Count of Bathrooms") +
  scale_color_brewer(palette = "Dark2") +
  scale_x_continuous(breaks = seq(0, max(single_family_homes$beds), by = 1)) +
  scale_y_continuous(breaks = seq(0, max(single_family_homes$baths), by = 1)) +
  theme_minimal() +
  theme(legend.position = "none",
        legend.background = element_rect(fill = "white",
        color = "black", size = 1, linetype = "solid"),
        axis.line = element_line(color = "black"))

ggsave("bed_vs_bath_scatter_plot.png", width = 10, height = 6, dpi = 300)

```

### 6. Final report: Heatmap of Baths vs Beds. Used this as a different approach to visualize

```{r}
# Revisiting the Bathrooms vs. Bedrooms visualization with a heatmap 

# Creating sub table to group the data by number of beds and baths.
# Then summarizes each group by the count column for # of records n()
heatmap_data <- single_family_homes %>%
  group_by(beds, baths) %>%
  summarise(count = n(), .groups = "drop") # preventing grouped dataframe 

# Checking result
# View(heatmap_data)

# Plotting heatmap of summarized data
ggplot(heatmap_data, aes(x = factor(beds), y = factor(baths), fill = count)) +
  geom_tile() +
  scale_fill_gradientn(colors = brewer.pal(9, "YlGnBu")) + # Using YlGnBu palette
  labs(title = "Heatmap of Bathrooms vs. Bedrooms for Single Family Homes",
       x = "Bedrooms", 
       y = "Bathrooms", 
       fill = "Count of Single Family Homes") +
  theme_linedraw() +
  theme(legend.position = "bottom",
        axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        plot.title = element_text(size = 20, hjust = 0.5), 
        axis.title = element_text(size = 16),
        panel.grid.major = element_blank(), # Removing gridlines
        panel.grid.minor = element_blank())

ggsave("bed_vs_bath_heatmap.png", width = 10, height = 6, dpi = 300)

```

```{r}
mean(single_family_homes$beds)
```

```{r}
mean(single_family_homes$baths)
```

### Experimenting with Mosaic Plots - Ken Vellian

1)	Create a visualization using one of the techniques from the latter half of the class (after the midterm).

```{r}
# Filtering out data where year_built != 1, year_built != 0
filtered_data_mosaic <- tx_data %>%
  filter(year_built != 1, year_built != 0)

# Categorizing 5 periods for year_built 
filtered_data_mosaic$year_built_period <- cut(filtered_data_mosaic$year_built,
                                       breaks = c(-Inf, 1899, 1945, 1999, 2010, Inf),
                                       labels = c("Before 1900 (Historic)", "1900-1945 (Early 20th Cent.)", "1946-1999 (Post-WWII-Late 20th Cent.)", "2000-2010 (Early 21st Cent.)", "2011-2024 (Modern)"))

```


```{r, warning = FALSE}
# Getting all the colors from the "RdPu" palette
all_colors_RdPu <- brewer.pal(9, "RdPu")

# Skipping the first 3 colors of the palette
colors_to_use_RdPu <- all_colors_RdPu[-(1:3)]

# Mosaic Plot of Property Type vs. Year Built Period
ggplot(data = filtered_data_mosaic) +
  geom_mosaic(aes(weight = 1, x = product(type), fill = year_built_period), na.rm = TRUE) +
  labs(title = "Mosaic Plot - Property Type vs. Year Built Period", x = "Property Type", y = "Year Built Period") +
  scale_fill_manual(values = colors_to_use_RdPu) +
  theme_minimal()+
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        axis.text.y = element_blank(),
        legend.position = "right",
        legend.background = element_rect(fill = "white", 
                                         color = "black", size = 1, linetype = "solid")) +
  guides(fill = guide_legend(title = "Year Built Period"))

```